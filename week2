Algorithm
1184.环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 184.的车站之间的距离。
环线上的公交车都可以按顺时针和逆时针的方向行驶。
返回乘客从出发点 start 到目的地 destination 之间的最短距离。
解法1:
class Solution {
    public int distanceBetweenBusStops(int[] distance, int start, int destination) {
           int clockWise = 0;
           int sumDistance = 0;
           for (int i = 0; i < distance.length; i++) {
               sumDistance += distance[i];
           }
           int temp;
           if (start > destination) {
               temp = start;
               start = destination;
               destination = temp;
           }
           for (int i = start; i < destination; i ++) {
               clockWise += distance[i];
           }
           if (clockWise < sumDistance - clockWise) {
               return clockWise;
           } else {
               return sumDistance - clockWise;
           }
            
    }
}
总结：第一次提交没有考虑到这是一个环形路线，导致提交错误，后面判断start与destination的大小来排除这种情况

Review

Tips
这次分享effective java中的第一个技巧：使用静态工厂方法而不是使用类的构造方法来获取类实例
使用这个技术主要有5个好处：
1.静态工厂方法有自己的名字，使其对调用者更加友善
2.使用类的构造方法获取类实例每次都是获得一个新的对象，而使用静态工厂方法可以实现单例，即每次获取的是相同的类实例
example:
Boolean.valueOf(boolean)的实现就是一个单例的静态工厂方法，这种场景下可以避免重复创建对象，节省内存。
3.使用静态工厂方法可以return 任意返回类型的任意子类
example：
java.util.Collections类中实现了42个集合类，这些集合类不是共有的，他们都是通过静态工厂方法进行返回，这些静态工厂的返回类型定义的都是不同类型的接口，具体实现时则可以返回这些接口的子类，大大增加了灵活性。
4.使用静态构造方法获取类的实例可以在不改变静态工厂方法签名的情况下，依据参数的不同来获取不同的子类，这样带来的好处是随着版本的更迭，调用者不需要去关心内部改变了什么，只需要像原来那样调用就行。
example：
jdk中的EnumSet抽象类，它没有提供任何公有的实现类，而是通过其内部的noneOf静态方法返回一个空的EnumSet的子类，该方法会根据传入的enum的长度来决定返回的是RegularEnumSet还是JumboEnumSet（EnumSet一共就这两个实现类），如果在后续jdk版本中，增加了新的EnumSet实现类，那么调用者根本不用关心获取的是哪个实现类，还是像原来那样使用EnumSet.noneof(Season.class)来进行调用即可。
5.静态工厂方法返回的类不需要是已经存在的
同时这个技巧也有不足之处
1.
2.
静态工厂方法的建议命名：
